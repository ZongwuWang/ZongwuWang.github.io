---
title: 多线程实例
password: www
abstract: 'Welcome to my blog, enter password to read.'
message: 'Welcome to my blog, enter password to read.'
date: 2022-03-08 21:00:57
tags:
- 操作系统
- 多线程
- pthread
categories: 操作系统
---

在操作系统导论一书的2.3节**并发**，有一个有趣的例子：

{% folding black close, 并发实例 %}
```c {.line-numbers}
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

volatile int counter = 0;
int loops;

void *worker(void *arg)
{
	int i;
	for (i = 0; i < loops; i++)
	{
		counter++;
	}

	return NULL;
}

int main(int argc, char *argv[])
{
	if (argc != 2)
	{
		fprintf(stderr, "usage: threads<value>\n");
		return 1;
	}
	loops = atoi(argv[1]);
	pthread_t p1, p2;
	printf("Initial value: %d\n", counter);

	pthread_create(&p1, NULL, worker, NULL);
	pthread_create(&p2, NULL, worker, NULL);
	pthread_join(p1, NULL);
	pthread_join(p1, NULL);
	printf("Final value: %d\n", counter);

	return 0;
}
```
{% endfolding %}

运行：
```shell
./thread 1000
```

不出意外的话结果为2000.

运行：
```shell
./thread 100000
```

结果则不是200000。

上面的程序中的关键部分是增加共享计数器的地方，它需要 3 条指令：一条将计数器的值从内存加载到寄存器，一条将其递增，操一条将其保存回内存。因为这 3 条指令并不是以原子方式（atomically）执行（所有的指令一一性执行）的，所以现现的事情可能会发生。

但是在docker使用--cpuset-cpus限定单核上运行以上程序，则不会发生错误，这是因为两个进程不会同时修改数据。