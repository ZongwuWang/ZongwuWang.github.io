---
title: ChampSim仿真器学习
password: www
abstract: 'Welcome to my blog, enter password to read.'
message: 'Welcome to my blog, enter password to read.'
date: 2022-03-20 17:20:46
tags:
- 仿真器
- ChampSim
- Simulator
- 分支预测
- Branch Prediction
- 预取
- Prefetch
categories: 计算机体系结构
---

## 1. ChampSim仿真器介绍

ChampSim is a trace-based microarchitectural simulator written in C++. ChampSim models a modern high-performance out-of-order (OoO) core and enables evaluating ideas on classical problems of microarchitectures like data prefetching, branch prediction and cache replacement policies. Unlike the timing simulator, ChampSim does not natively run an executable/assembly program but uses an instruction trace, extracted out from an application, to simulate the processor microarchitecture model.

github line: https://github.com/ChampSim/ChampSim

## 2. ChampSim源码介绍

We will briefly walk you through the major directories of ChampSim and explain their functionality. Do **Not** modify any of these files or directories unless explicity mentioned.

- **inc:** This directory contains all the header fles. These headers will automatically get included during the compilation. *Do not change any parameters in these fles.* If you create any header file by yourself while implementing prefetchers, you need to put it here.
- **src:** This directory contains files that define the microarchitecture of an OoO core, uncore, cache and DRAM controller. You might skim through these files to get a better understanding of ChampSim.
- **branch** and **replacement:** These directories contain the source code of different branch predictors and last level cache (LLC, in our case it is L3) management policies. You can use the perceptron branch predictor and SHiP cache management policy for the LLC for execise.
- **prefetch:** ChampSim is extensible to implement
prefetchers at all three cache levels. Take L2 prefetcher as an example, the L2 prefetcher API is defined in l2c prefetcher.cc file. The API consists of five key functions:
	- **l2c_prefetcher_initialize:** This function is called when the cache gets created and should be used to initialize any internal data structures of the prefetcher.
	- **l2c_prefetcher_final_stats:** This is the final function that is called at the end of simulation. This can be a good palce to print overall statistics of the prefetcher.
	- **l2c_prefetcher_operate:** This function is called for *each L2 lookup operation.* This means it is called for both L2 load and store accesses that can either hit or miss in the cache. The third and fourth arguements of this function helps in identifying the type of lookup.
	- **l2c_prefetcher_cache_fill:** This function is called for *each L2 fill operation.* This function arguement names are self explanatory.
	- **prefetch_line:** You do *NOT* need to implement this function, but to use it when a prefetch request needs to be injected into the memory hierarchy. (Tip: see how this function is used in ==next_line.l2c_perf== or ==ip_stride.l2c_perf). The first two arguments are the PC and the cacheline address of the access that triggers this prefetch request. The third argument is the cacheline address of the prefetch request. By default, a prefetch request generated by the prefetcher at a cache level N first looks up the Nth-level cache. On a miss, the prefetch request looks up the next cache levels (N+1;N+2 etc) and eventually goes to main memory if it misses in the LLC. Once the memory supplies the corresponding data, the prefetched cachelines gets filled in all cache levels from the LLC to the Nth level. However, you can modify the prefetcher to send a hint to the memory subsystem to refrain from filling the cacheline in all cache levels if you think filling a prefetched line in all cache levels might hurt performance. This hint is passed by the fourth argument, ==pr_fill_level==. For a L2 prefetcher, this argument can take either of the two values ==FILL_L2== or ==FILL_LLC==.

## 3. 编译运行

编译和运行主要可以参考github中README文件，运行之前需要先运行${ChammpSim_ROOT}/scripts/download_dpc3_traces.sh脚本下载trace文件，比较简单。

编译生成的可执行文件位于${ChampSim_ROOT}/bin文件夹下，运行生成的结果位于${ChammpSim_ROOT}/results_${N_SIM}路径下。

这边需要注意的是在运行时${N_WARM}和${N_SIM}的单位都为Million。

为了更方便的运行仿真和分析结果，我编写了两个bash脚本。

{% folding black close, batch run simulation %}
```shell
#!/bin/bash
###
 # @Author: Wang Zongwu
 # @Date: 2021-06-06 00:04:44
 # @LastEditTime: 2022-03-20 16:36:25
 # @LastEditors: Wang Zongwu
 # @Description: Run the simulation for all traces in the folder "dpc3_traces"
 # @FilePath: /tmp/home/wzw/Documents/ACA_Proj/Tools/ChampSim/batch_sim.bash
### 

# Parameters
# $1: binary
# $2: N_WARM
# $3: N_SIM

binary = bimodal-no-no-no-no-lru-1core
N_WARM = 1
N_SIM = 10

if [ $# -eq 1 ] then
    binary = $1
fi

files=$(ls ./dpc3_traces)

for file in $files
do
    echo `basename $file`
    ./run_champsim.sh $binary $N_WARM $N_SIM $file &
done
```
{% endfolding %}

{% folding black close, analyze the results %}
```shell
##########################################################################
# File Name: extractResults.sh
# Author: Wang Zongwu
# mail: wangzongwu@outlook.com
# Created Time: Wed 20 Oct 2021 05:54:35 PM CST
# Description: A demo script for extracting the results(MPKI)
#########################################################################
#!/bin/bash

awk '/MPKI/{printf "%9.4f\t%s\n", $8, FILENAME}' ../results_10M/*
```
{% endfolding %}

## 4. ChampSim源代码梳理

首先定位到${ChampSim_ROOT}/src/main.cc.

{% folding block close, ChampSim main函数梳理 %}
```c {.line-numbers}
int main(int argc, char** argv)
{
	// interrupt signal hanlder
    /*
    http://c.biancheng.net/cpp/html/1142.html
    https://blog.csdn.net/weibo1230123/article/details/81411827
    头文件：#include <signal.h>
    定义函数：int sigaction(int signum, 
                           const struct sigaction *act,
                           struct sigaction *oldact);
    函数说明：sigaction()会依参数signum指定的信号编号来设置该信号的处理函数。参数signum可以指定SIGKILL和SIGSTOP以外的所有信号。

    参数结构sigaction定义如下：
    struct sigaction {
    void (*sa_handler)(int);
    void (*sa_sigaction)(int, siginfo_t *, void *);
    sigset_t sa_mask;
    int sa_flags;
    void (*sa_restorer)(void);
    }
    1、sa_handler 此参数和signal()的参数handler 相同, 代表新的信号处理函数, 其他意义请参考signal().
    2、sa_mask 用来设置在处理该信号时暂时将sa_mask 指定的信号搁置.
    3、sa_restorer 此参数没有使用.
    4、sa_flags 用来设置信号处理的其他相关操作, 下列的数值可用：
       A_NOCLDSTOP: 如果参数signum 为SIGCHLD, 则当子进程暂停时并不会通知父进程
       SA_ONESHOT/SA_RESETHAND: 当调用新的信号处理函数前, 将此信号处理方式改为系统预设的方式.
       SA_RESTART: 被信号中断的系统调用会自行重启
       SA_NOMASK/SA_NODEFER: 在处理此信号未结束前不理会此信号的再次到来. 如果参数oldact 不是NULL 指针, 则原来的信号处理方式会由此结构sigaction 返回.

    返回值：执行成功则返回0, 如果有错误则返回-1.
    */
	struct sigaction sigIntHandler;
	sigIntHandler.sa_handler = signal_handler;
    /*
    头文件：#include <signal.h>
    定义函数：int sigemptyset(sigset_t *set);
    函数说明：sigemptyset()用来将参数set信号集初始化并清空
    返回值：执行成功则返回0，如果有错则返回-1.
    */
	sigemptyset(&sigIntHandler.sa_mask);
	sigIntHandler.sa_flags = 0;
	sigaction(SIGINT, &sigIntHandler, NULL);

    cout << endl << "*** ChampSim Multicore Out-of-Order Simulator ***" << endl << endl;

    // initialize knobs
    uint8_t show_heartbeat = 1;

    uint32_t seed_number = 0;

    // check to see if knobs changed using getopt_long()
    int c;
    while (1) {
        static struct option long_options[] =
        {
            {"warmup_instructions", required_argument, 0, 'w'},
            {"simulation_instructions", required_argument, 0, 'i'},
            {"hide_heartbeat", no_argument, 0, 'h'},
            {"cloudsuite", no_argument, 0, 'c'},
            {"low_bandwidth",  no_argument, 0, 'b'},
            {"traces",  no_argument, 0, 't'},
            {0, 0, 0, 0}      
        };

        int option_index = 0;
        /*
        https://blog.csdn.net/pengrui18/article/details/8078813
        int getopt_long_only (int ___argc, 
                              char *const *___argv,  
                              const char *__shortopts,  
                              const struct option *__longopts, 
                              int *__longind); 
        argc, argv：直接从main函数传递而来
        shortopts：短选项字符串。如”n:v"，这里需要指出的是，短选项字符串不需要‘-’，而且但选项需要传递参数时，在短选项后面加上“：”。
        longopts：struct option 数组，用于存放长选项参数。
        longind：用于返回长选项在longopts结构体数组中的索引值，用于调试。一般置为NULL
        struct option介绍：
            struct option  
            {  
            const char *name;//长选项名  
            int has_arg;//是否需要参数  
            int *flag;  
            int val;  
            };  
            name：长选项名字
            has_arg:是否需要参数。值有三种情况

                # define no_argument        0    //不需要参数  
                # define required_argument  1    //必须指定参数  
                # define optional_argument  2    //参数可选
            flag和val相互依赖，主要分两种情况：
                （1）、flag为NULL，val值用于确定该长选项，所以需要为长选项指定唯一的val值。这里也为长选项和短选项建立了桥梁。
                （2）、flag不为NULL，则将val值存放到flag所指向的存储空间，用于标识该长选项出现过。
        返回值：
            1. 程序中使用短选项，则返回短选项字符（如‘n'），当需要参数是，则在返回之前将参数存入到optarg中。
            2. 程序中使用长选项，返回值根据flag和val确定。当flag为NULL，则返回val值。所以根据val值做不同的处理，这也说明了val必须唯一。当val值等于短选项值，则可以使用短选项解析函数解析长选项；当flag不为NULL，则将val值存入flag所指向的存储空间，getopt_long返回0
            3. 出现未定义的长选项或者短选项，getopt_long返回？
            4. 解析完毕，getopt_long返回-1
        */
        c = getopt_long_only(argc, argv, "wihsb", long_options, &option_index);

        // no more option characters
        if (c == -1)
            break;

        int traces_encountered = 0;

        switch(c) {
            case 'w':
                warmup_instructions = atol(optarg);
                break;
            case 'i':
                simulation_instructions = atol(optarg);
                break;
            case 'h':
                show_heartbeat = 0;
                break;
            case 'c':
                knob_cloudsuite = 1;
                MAX_INSTR_DESTINATIONS = NUM_INSTR_DESTINATIONS_SPARC;
                break;
            case 'b':
                knob_low_bandwidth = 1;
                break;
            case 't':
                traces_encountered = 1;
                break;
            default:
                abort();
        }

        if (traces_encountered == 1)
            break;
    }

    // consequences of knobs
    cout << "Warmup Instructions: " << warmup_instructions << endl;
    cout << "Simulation Instructions: " << simulation_instructions << endl;
    //cout << "Scramble Loads: " << (knob_scramble_loads ? "ture" : "false") << endl;
    cout << "Number of CPUs: " << NUM_CPUS << endl;
    cout << "LLC sets: " << LLC_SET << endl;
    cout << "LLC ways: " << LLC_WAY << endl;

    if (knob_low_bandwidth)
        DRAM_MTPS = DRAM_IO_FREQ/4;
    else
        DRAM_MTPS = DRAM_IO_FREQ;

    // DRAM access latency
    tRP  = (uint32_t)((1.0 * tRP_DRAM_NANOSECONDS  * CPU_FREQ) / 1000);         // 发送指令时间
    tRCD = (uint32_t)((1.0 * tRCD_DRAM_NANOSECONDS * CPU_FREQ) / 1000);         // 激活行时间
    tCAS = (uint32_t)((1.0 * tCAS_DRAM_NANOSECONDS * CPU_FREQ) / 1000);         // Column read/restore时间

    // default: 16 = (64 / 8) * (3200 / 1600)
    // it takes 16 CPU cycles to tranfser 64B cache block on a 8B (64-bit) bus 
    // note that dram burst length = BLOCK_SIZE/DRAM_CHANNEL_WIDTH
    DRAM_DBUS_RETURN_TIME = (BLOCK_SIZE / DRAM_CHANNEL_WIDTH) * (CPU_FREQ / DRAM_MTPS);

    printf("Off-chip DRAM Size: %u MB Channels: %u Width: %u-bit Data Rate: %u MT/s\n",
            DRAM_SIZE, DRAM_CHANNELS, 8*DRAM_CHANNEL_WIDTH, DRAM_MTPS);

    // end consequence of knobs

    // search through the argv for "-traces"
    int found_traces = 0;
    int count_traces = 0;
    cout << endl;
    for (int i=0; i<argc; i++) {
        if (found_traces)
        {
            printf("CPU %d runs %s\n", count_traces, argv[i]);

            sprintf(ooo_cpu[count_traces].trace_string, "%s", argv[i]);

            std::string full_name(argv[i]);
            std::string last_dot = full_name.substr(full_name.find_last_of("."));

            std::string fmtstr;
            std::string decomp_program;
            if (full_name.substr(0,4) == "http")
            {
                // Check file exists
                char testfile_command[4096];
                sprintf(testfile_command, "wget -q --spider %s", argv[i]);
                FILE *testfile = popen(testfile_command, "r");
                if (pclose(testfile))
                {
                    std::cerr << "TRACE FILE NOT FOUND" << std::endl;
                    assert(0);
                }
                fmtstr = "wget -qO- %2$s | %1$s -dc";
            }
            else
            {
                std::ifstream testfile(argv[i]);
                if (!testfile.good())
                {
                    std::cerr << "TRACE FILE NOT FOUND" << std::endl;
                    assert(0);
                }
                fmtstr = "%1$s -dc %2$s";
            }

            if (last_dot[1] == 'g') // gzip format
                decomp_program = "gzip";
            else if (last_dot[1] == 'x') // xz
                decomp_program = "xz";
            else {
                std::cout << "ChampSim does not support traces other than gz or xz compression!" << std::endl;
                assert(0);
            }

            sprintf(ooo_cpu[count_traces].gunzip_command, fmtstr.c_str(), decomp_program.c_str(), argv[i]);

            char *pch[100];
            int count_str = 0;
            pch[0] = strtok (argv[i], " /,.-");
            while (pch[count_str] != NULL) {
                //printf ("%s %d\n", pch[count_str], count_str);
                count_str++;
                pch[count_str] = strtok (NULL, " /,.-");
            }

            //printf("max count_str: %d\n", count_str);
            //printf("application: %s\n", pch[count_str-3]);

            int j = 0;
            while (pch[count_str-3][j] != '\0') {
                seed_number += pch[count_str-3][j];
                //printf("%c %d %d\n", pch[count_str-3][j], j, seed_number);
                j++;
            }

            ooo_cpu[count_traces].trace_file = popen(ooo_cpu[count_traces].gunzip_command, "r");
            if (ooo_cpu[count_traces].trace_file == NULL) {
                printf("\n*** Trace file not found: %s ***\n\n", argv[i]);
                assert(0);
            }

            count_traces++;
            if (count_traces > NUM_CPUS) {
                printf("\n*** Too many traces for the configured number of cores ***\n\n");
                assert(0);
            }
        }
        else if(strcmp(argv[i],"-traces") == 0) {
            found_traces = 1;
        }
    }

    if (count_traces != NUM_CPUS) {
        printf("\n*** Not enough traces for the configured number of cores ***\n\n");
        assert(0);
    }
    // end trace file setup

    // TODO: can we initialize these variables from the class constructor?
    srand(seed_number);
    champsim_seed = seed_number;
    for (int i=0; i<NUM_CPUS; i++) {

        ooo_cpu[i].cpu = i; 
        ooo_cpu[i].warmup_instructions = warmup_instructions;
        ooo_cpu[i].simulation_instructions = simulation_instructions;
        ooo_cpu[i].begin_sim_cycle = 0; 
        ooo_cpu[i].begin_sim_instr = warmup_instructions;

        // ROB
        ooo_cpu[i].ROB.cpu = i;

        // BRANCH PREDICTOR
        ooo_cpu[i].initialize_branch_predictor();

        // TLBs
        ooo_cpu[i].ITLB.cpu = i;
        ooo_cpu[i].ITLB.cache_type = IS_ITLB;
	    ooo_cpu[i].ITLB.MAX_READ = 2;
        ooo_cpu[i].ITLB.fill_level = FILL_L1;
        ooo_cpu[i].ITLB.extra_interface = &ooo_cpu[i].L1I;
        ooo_cpu[i].ITLB.lower_level = &ooo_cpu[i].STLB; 

        ooo_cpu[i].DTLB.cpu = i;
        ooo_cpu[i].DTLB.cache_type = IS_DTLB;
        //ooo_cpu[i].DTLB.MAX_READ = (2 > MAX_READ_PER_CYCLE) ? MAX_READ_PER_CYCLE : 2;
        ooo_cpu[i].DTLB.MAX_READ = 2;
        ooo_cpu[i].DTLB.fill_level = FILL_L1;
        ooo_cpu[i].DTLB.extra_interface = &ooo_cpu[i].L1D;
        ooo_cpu[i].DTLB.lower_level = &ooo_cpu[i].STLB;

        ooo_cpu[i].STLB.cpu = i;
        ooo_cpu[i].STLB.cache_type = IS_STLB;
        ooo_cpu[i].STLB.MAX_READ = 1;
        ooo_cpu[i].STLB.fill_level = FILL_L2;
        ooo_cpu[i].STLB.upper_level_icache[i] = &ooo_cpu[i].ITLB;
        ooo_cpu[i].STLB.upper_level_dcache[i] = &ooo_cpu[i].DTLB;

        // PRIVATE CACHE
        ooo_cpu[i].L1I.cpu = i;
        ooo_cpu[i].L1I.cache_type = IS_L1I;
        //ooo_cpu[i].L1I.MAX_READ = (FETCH_WIDTH > MAX_READ_PER_CYCLE) ? MAX_READ_PER_CYCLE : FETCH_WIDTH;
        ooo_cpu[i].L1I.MAX_READ = 2;
        ooo_cpu[i].L1I.fill_level = FILL_L1;
        ooo_cpu[i].L1I.lower_level = &ooo_cpu[i].L2C; 
        ooo_cpu[i].l1i_prefetcher_initialize();
	    ooo_cpu[i].L1I.l1i_prefetcher_cache_operate = cpu_l1i_prefetcher_cache_operate;
	    ooo_cpu[i].L1I.l1i_prefetcher_cache_fill = cpu_l1i_prefetcher_cache_fill;

        ooo_cpu[i].L1D.cpu = i;
        ooo_cpu[i].L1D.cache_type = IS_L1D;
        ooo_cpu[i].L1D.MAX_READ = (2 > MAX_READ_PER_CYCLE) ? MAX_READ_PER_CYCLE : 2;
        ooo_cpu[i].L1D.fill_level = FILL_L1;
        ooo_cpu[i].L1D.lower_level = &ooo_cpu[i].L2C; 
        ooo_cpu[i].L1D.l1d_prefetcher_initialize();

        ooo_cpu[i].L2C.cpu = i;
        ooo_cpu[i].L2C.cache_type = IS_L2C;
        ooo_cpu[i].L2C.fill_level = FILL_L2;
        ooo_cpu[i].L2C.upper_level_icache[i] = &ooo_cpu[i].L1I;
        ooo_cpu[i].L2C.upper_level_dcache[i] = &ooo_cpu[i].L1D;
        ooo_cpu[i].L2C.lower_level = &uncore.LLC;
        ooo_cpu[i].L2C.l2c_prefetcher_initialize();

        // SHARED CACHE
        uncore.LLC.cache_type = IS_LLC;
        uncore.LLC.fill_level = FILL_LLC;
        uncore.LLC.MAX_READ = NUM_CPUS;
        uncore.LLC.upper_level_icache[i] = &ooo_cpu[i].L2C;
        uncore.LLC.upper_level_dcache[i] = &ooo_cpu[i].L2C;
        uncore.LLC.lower_level = &uncore.DRAM;

        // OFF-CHIP DRAM
        uncore.DRAM.fill_level = FILL_DRAM;
        uncore.DRAM.upper_level_icache[i] = &uncore.LLC;
        uncore.DRAM.upper_level_dcache[i] = &uncore.LLC;
        for (uint32_t i=0; i<DRAM_CHANNELS; i++) {
            uncore.DRAM.RQ[i].is_RQ = 1;
            uncore.DRAM.WQ[i].is_WQ = 1;
        }

        warmup_complete[i] = 0;
        //all_warmup_complete = NUM_CPUS;
        simulation_complete[i] = 0;
        current_core_cycle[i] = 0;
        stall_cycle[i] = 0;
        
        previous_ppage = 0;
        num_adjacent_page = 0;
        num_cl[i] = 0;
        allocated_pages = 0;
        num_page[i] = 0;
        minor_fault[i] = 0;
        major_fault[i] = 0;
    }

    uncore.LLC.llc_initialize_replacement();
    uncore.LLC.llc_prefetcher_initialize();

    // simulation entry point
    start_time = time(NULL);
    uint8_t run_simulation = 1;
    while (run_simulation) {

        uint64_t elapsed_second = (uint64_t)(time(NULL) - start_time),
                 elapsed_minute = elapsed_second / 60,
                 elapsed_hour = elapsed_minute / 60;
        elapsed_minute -= elapsed_hour*60;
        elapsed_second -= (elapsed_hour*3600 + elapsed_minute*60);

        for (int i=0; i<NUM_CPUS; i++) {
            // proceed one cycle
            current_core_cycle[i]++;

            //cout << "Trying to process instr_id: " << ooo_cpu[i].instr_unique_id << " fetch_stall: " << +ooo_cpu[i].fetch_stall;
            //cout << " stall_cycle: " << stall_cycle[i] << " current: " << current_core_cycle[i] << endl;

            // core might be stalled due to page fault or branch misprediction
            if (stall_cycle[i] <= current_core_cycle[i]) {

                // retire
                if ((ooo_cpu[i].ROB.entry[ooo_cpu[i].ROB.head].executed == COMPLETED) && (ooo_cpu[i].ROB.entry[ooo_cpu[i].ROB.head].event_cycle <= current_core_cycle[i]))
                ooo_cpu[i].retire_rob();

                // complete 
                ooo_cpu[i].update_rob();

                // schedule
                uint32_t schedule_index = ooo_cpu[i].ROB.next_schedule;
                if ((ooo_cpu[i].ROB.entry[schedule_index].scheduled == 0) && (ooo_cpu[i].ROB.entry[schedule_index].event_cycle <= current_core_cycle[i]))
                ooo_cpu[i].schedule_instruction();
                // execute
                ooo_cpu[i].execute_instruction();

                ooo_cpu[i].update_rob();

                // memory operation
                ooo_cpu[i].schedule_memory_instruction();
                ooo_cpu[i].execute_memory_instruction();

                ooo_cpu[i].update_rob();

                // decode
                if(ooo_cpu[i].DECODE_BUFFER.occupancy > 0)
                {
                ooo_cpu[i].decode_and_dispatch();
                }
                
                // fetch
                ooo_cpu[i].fetch_instruction();
                
                // read from trace
                if ((ooo_cpu[i].IFETCH_BUFFER.occupancy < ooo_cpu[i].IFETCH_BUFFER.SIZE) && (ooo_cpu[i].fetch_stall == 0))
                {
                ooo_cpu[i].read_from_trace();
                }
            }

            // heartbeat information
            if (show_heartbeat && (ooo_cpu[i].num_retired >= ooo_cpu[i].next_print_instruction)) {
                float cumulative_ipc;
                if (warmup_complete[i])
                    cumulative_ipc = (1.0*(ooo_cpu[i].num_retired - ooo_cpu[i].begin_sim_instr)) / (current_core_cycle[i] - ooo_cpu[i].begin_sim_cycle);
                else
                    cumulative_ipc = (1.0*ooo_cpu[i].num_retired) / current_core_cycle[i];
                float heartbeat_ipc = (1.0*ooo_cpu[i].num_retired - ooo_cpu[i].last_sim_instr) / (current_core_cycle[i] - ooo_cpu[i].last_sim_cycle);

                cout << "Heartbeat CPU " << i << " instructions: " << ooo_cpu[i].num_retired << " cycles: " << current_core_cycle[i];
                cout << " heartbeat IPC: " << heartbeat_ipc << " cumulative IPC: " << cumulative_ipc; 
                cout << " (Simulation time: " << elapsed_hour << " hr " << elapsed_minute << " min " << elapsed_second << " sec) " << endl;
                ooo_cpu[i].next_print_instruction += STAT_PRINTING_PERIOD;

                ooo_cpu[i].last_sim_instr = ooo_cpu[i].num_retired;
                ooo_cpu[i].last_sim_cycle = current_core_cycle[i];
            }

            // check for deadlock
            if (ooo_cpu[i].ROB.entry[ooo_cpu[i].ROB.head].ip && (ooo_cpu[i].ROB.entry[ooo_cpu[i].ROB.head].event_cycle + DEADLOCK_CYCLE) <= current_core_cycle[i])
                print_deadlock(i);

            // check for warmup
            // warmup complete
            if ((warmup_complete[i] == 0) && (ooo_cpu[i].num_retired > warmup_instructions)) {
                warmup_complete[i] = 1;
                all_warmup_complete++;
            }
            if (all_warmup_complete == NUM_CPUS) { // this part is called only once when all cores are warmed up
                all_warmup_complete++;
                finish_warmup();
            }

            /*
            if (all_warmup_complete == 0) { 
                all_warmup_complete = 1;
                finish_warmup();
            }
            if (ooo_cpu[1].num_retired > 0)
                warmup_complete[1] = 1;
            */
            
            // simulation complete
            if ((all_warmup_complete > NUM_CPUS) && (simulation_complete[i] == 0) && (ooo_cpu[i].num_retired >= (ooo_cpu[i].begin_sim_instr + ooo_cpu[i].simulation_instructions))) {
                simulation_complete[i] = 1;
                ooo_cpu[i].finish_sim_instr = ooo_cpu[i].num_retired - ooo_cpu[i].begin_sim_instr;
                ooo_cpu[i].finish_sim_cycle = current_core_cycle[i] - ooo_cpu[i].begin_sim_cycle;

                cout << "Finished CPU " << i << " instructions: " << ooo_cpu[i].finish_sim_instr << " cycles: " << ooo_cpu[i].finish_sim_cycle;
                cout << " cumulative IPC: " << ((float) ooo_cpu[i].finish_sim_instr / ooo_cpu[i].finish_sim_cycle);
                cout << " (Simulation time: " << elapsed_hour << " hr " << elapsed_minute << " min " << elapsed_second << " sec) " << endl;

                record_roi_stats(i, &ooo_cpu[i].L1D);
                record_roi_stats(i, &ooo_cpu[i].L1I);
                record_roi_stats(i, &ooo_cpu[i].L2C);
                record_roi_stats(i, &uncore.LLC);

                all_simulation_complete++;
            }

            if (all_simulation_complete == NUM_CPUS)
                run_simulation = 0;
        }

        // TODO: should it be backward?
        uncore.DRAM.operate();
        uncore.LLC.operate();
    }

    uint64_t elapsed_second = (uint64_t)(time(NULL) - start_time),
             elapsed_minute = elapsed_second / 60,
             elapsed_hour = elapsed_minute / 60;
    elapsed_minute -= elapsed_hour*60;
    elapsed_second -= (elapsed_hour*3600 + elapsed_minute*60);
    
    cout << endl << "ChampSim completed all CPUs" << endl;
    if (NUM_CPUS > 1) {
        cout << endl << "Total Simulation Statistics (not including warmup)" << endl;
        for (uint32_t i=0; i<NUM_CPUS; i++) {
            cout << endl << "CPU " << i << " cumulative IPC: " << (float) (ooo_cpu[i].num_retired - ooo_cpu[i].begin_sim_instr) / (current_core_cycle[i] - ooo_cpu[i].begin_sim_cycle); 
            cout << " instructions: " << ooo_cpu[i].num_retired - ooo_cpu[i].begin_sim_instr << " cycles: " << current_core_cycle[i] - ooo_cpu[i].begin_sim_cycle << endl;
#ifndef CRC2_COMPILE
            print_sim_stats(i, &ooo_cpu[i].L1D);
            print_sim_stats(i, &ooo_cpu[i].L1I);
            print_sim_stats(i, &ooo_cpu[i].L2C);
	    ooo_cpu[i].l1i_prefetcher_final_stats();
            ooo_cpu[i].L1D.l1d_prefetcher_final_stats();
	    ooo_cpu[i].L2C.l2c_prefetcher_final_stats();
#endif
            print_sim_stats(i, &uncore.LLC);
        }
        uncore.LLC.llc_prefetcher_final_stats();
    }

    cout << endl << "Region of Interest Statistics" << endl;
    for (uint32_t i=0; i<NUM_CPUS; i++) {
        cout << endl << "CPU " << i << " cumulative IPC: " << ((float) ooo_cpu[i].finish_sim_instr / ooo_cpu[i].finish_sim_cycle); 
        cout << " instructions: " << ooo_cpu[i].finish_sim_instr << " cycles: " << ooo_cpu[i].finish_sim_cycle << endl;
#ifndef CRC2_COMPILE
        print_roi_stats(i, &ooo_cpu[i].L1D);
        print_roi_stats(i, &ooo_cpu[i].L1I);
        print_roi_stats(i, &ooo_cpu[i].L2C);
#endif
        print_roi_stats(i, &uncore.LLC);
        cout << "Major fault: " << major_fault[i] << " Minor fault: " << minor_fault[i] << endl;
    }

    for (uint32_t i=0; i<NUM_CPUS; i++) {
        ooo_cpu[i].l1i_prefetcher_final_stats();
        ooo_cpu[i].L1D.l1d_prefetcher_final_stats();
        ooo_cpu[i].L2C.l2c_prefetcher_final_stats();
    }

    uncore.LLC.llc_prefetcher_final_stats();

#ifndef CRC2_COMPILE
    uncore.LLC.llc_replacement_final_stats();
    print_dram_stats();
    print_branch_stats();
#endif

    return 0;
}
```
{% endfolding %}

1. 在以上代码的前257行主要进行参数的处理以及DRAM时延的设置等，大概扫一眼就可以。
2. 第257~353行用于系统的配置，主要包括cpu、ROB、分支预测器、TLB（包括ITLB、DTLB、STLB）、Private Cache（L1I, L1D和L2C）、Shared Cache（LLC）、Off-Chip DRAM等。
3. 第355，356两行对LLC替换策略和LLC预取器进行初始化。
4. 第359~484行到最后为仿真运行过程，为一个while循环，该循环的退出条件为所有CPU都完成了对应的trace仿真。
   - 第363~367行统计当前运行时间，以Hour:Minute:Second显示。
   - 第369~479行的for循环依次执行各个CPU的cycle。
     - 首先将当前运行的cycle加1。
     - 其次判断==stall_cycle[i] <= current_core_cycle[i]== 是否成立，stall_cycle为每次遇到分支预测错误或page fault时，将当前的cycle加上需要stall的cycle数，如果以上条件成立，则表明CPU没有stall，继续接下来的操作，否则不进行任何操作，直接跳转到第x步。
     - 如果CPU没有Stall，则从流水线的最后端向最前端依次进行处理：retire->complete->schedule->execute->memory operation->decode->fetch->read from trace. By the way，分支预测仿真则是在read from trace阶段完成。
   - 第417~433行显示beatheart information，即是否在每个时钟周期显示当前的统计信息。
   - 第435~448行检查死锁和warmup是否完成。
   - 第459~475行检查retire的指令数是否达到设置的${N_SIM}，如果达到表明当前CPU的仿真完成。
   - 第477~478行，如果所有CPU都完成仿真，设置退出仿真循环条件。
   - 第482~483行处理每个CPU cycle之后的DRAM操作和LLC操作。
 - 第486到结束，统计信息并输出。







## Reference

- [1] [现代中央处理器（CPU）是怎样进行分支预测的？ - 秦冕的回答 - 知乎](https://www.zhihu.com/question/486239354/answer/2129757853)
- [2] https://github.com/ChampSim/ChampSim
- [3] https://safari.ethz.ch/architecture/fall2020/lib/exe/fetch.php?media=lab4.pdf