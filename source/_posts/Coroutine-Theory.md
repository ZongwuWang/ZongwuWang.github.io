---
title: Coroutine Theory
categories:
- 编程开发
password: www
abstract: 'Welcome to my blog, enter password to read.'
message: 'Welcome to my blog, enter password to read.'
date: 2022-11-28 08:53:29
tags:
- Coroutine
- 协程
---

这是关于[C++ Coroutines TS](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4680.pdf)的系列博文中的第一篇，C++ Coroutines TS是一种新的语言特性，目前有望纳入 C++20 语言标准。

在本系列中，我将介绍 C++ Coroutines 的底层机制是如何工作的，并展示如何使用它们来构建有用的高级抽象，例如[cppcoro](https://github.com/lewissbaker/cppcoro)库提供的抽象。

在这篇文章中，我将描述函数和协程之间的区别，并提供一些关于它们支持的操作的理论。 这篇文章的目的是介绍一些基础概念，这些概念将有助于构建您对 C++ 协程的思考方式。

## 协程是函数是协程

协程是函数的泛化，它允许函数被挂起，然后再恢复。

我将更详细地解释这意味着什么，但在此之前，我想先回顾一下“普通”C++ 函数的工作原理。

## 普通函数

一个普通函数可以被认为有两个操作：Call 和 Return（请注意，我在这里将“抛出异常”概括地归为 Return 操作）。

Call 操作创建一个激活帧，暂停调用函数的执行并将执行转移到被调用函数的开始。

Return 操作将返回值传递给调用者，销毁激活帧，然后在调用函数的那一点之后恢复调用者的执行。

让我们再分析一下这些语义……

### 激活帧（Activation Frames）

那么这个“激活帧”是什么东西？

您可以将激活帧视为保存特定函数调用当前状态的内存块。 此状态包括传递给它的任何参数的值和任何局部变量的值。

对于“普通”函数，激活帧还包括返回地址——从函数返回时将执行转移到的指令的地址——以及用于调用调用函数的激活帧的地址。

您可以将这些信息片段一起视为描述函数调用的“继续”，即，它们描述了在该函数完成时应继续执行哪个函数的哪个调用。

对于“正常”函数，所有激活帧都具有严格嵌套的生命周期。 这种严格的嵌套允许使用高效的内存分配数据结构来为每个函数调用分配和释放激活帧。 这种数据结构通常被称为“栈”。

当在这个栈数据结构上分配一个激活帧时，它通常被称为“栈帧”。

这种栈数据结构非常普遍，以至于大多数（所有？）CPU 架构都有一个专用寄存器来保存指向栈顶部的指针（例如，在 X64 中，它是 rsp 寄存器）。

要为新的激活帧分配空间，只需将此寄存器增加帧大小即可。要为激活帧释放空间，只需将此寄存器减去帧大小即可。

### "Call"操作

当一个函数调用另一个函数时，调用者必须首先为挂起做好准备。

这个“暂停”步骤通常涉及将当前保存在 CPU 寄存器中的任何值保存到内存中，以便以后可以在函数恢复执行时根据需要恢复这些值。 根据函数的调用约定，调用者和被调用者可以协调谁保存这些寄存器值，但您仍然可以认为它们是作为 Call 操作的一部分执行的。

调用者还将传递给被调用函数的任何参数的值存储到新的激活帧中，函数可以在其中访问它们。

最后，调用者将调用者的恢复点地址写入新的激活帧并将执行转移到被调用函数的开头。

在 X86/X64 体系结构中，这个最终操作有自己的指令，call指令，它将下一条指令的地址写入栈，将堆栈寄存器递增地址的大小，然后跳转到指令操作数中指定的地址。

### "Return"操作

当函数通过返回语句返回时，函数首先将返回值（如果有）存储在调用者可以访问的位置。 这可能在调用者的激活帧或函数的激活帧中（对于跨越两个激活帧之间边界的参数和返回值，区别可能会有点模糊）。

然后该函数通过以下方式破坏激活帧：

- 在返回点销毁范围内的任何局部变量
- 销毁任何参数对象
- 释放激活帧使用的内存

最后，它通过以下方式恢复调用者的执行：

- 通过将栈寄存器设置为指向调用者的激活帧并恢复可能已被该函数破坏的任何寄存器来恢复调用者的激活帧
- 跳转到在“call”操作期间存储的调用者的恢复点

请注意，与“调用”操作一样，某些调用约定可能会将“返回”操作的职责拆分为调用者和被调用者函数指令。

## 协程

协程通过将 Call 和 Return 操作中执行的一些步骤分离为三个额外的操作来概括函数的操作：Suspend、Resume 和 Destroy。

Suspend操作在函数内的当前点暂停协程的执行，并将执行转移回调用者或恢复者而不破坏激活帧。在协程执行暂停后，暂停点范围内的任何对象仍然存在。

请注意，与函数的 Return 操作一样，协程只能在协程本身内在明确定义的挂起点处挂起。

Resume 操作在挂起点恢复挂起协程的执行，这将重新激活协程的激活帧。

Destroy 操作会在不恢复协程执行的情况下销毁激活帧。 在挂起点范围内的任何对象都将被销毁。 用于存储激活帧的内存被释放。

### 协程激活帧

由于可以在不破坏激活帧的情况下暂停协程，因此我们无法再保证激活帧的生命周期将严格嵌套。 这意味着激活帧通常不能使用堆栈数据结构进行分配，因此可能需要存储在堆上。

C++ Coroutines TS 中有一些规定，如果编译器可以证明协程的生命周期确实严格嵌套在调用者的生命周期内，则允许从调用者的激活帧分配协程框架的内存。如果您有一个足够智能的编译器，这可以在许多情况下避免堆分配。

对于协程，激活帧的某些部分需要在协程挂起时保留，而某些部分只需要在协程执行时保留。例如，范围不跨越任何协程挂起点的变量的生命周期可能存储在栈中。

你可以在逻辑上认为协程的激活帧由两部分组成：“协程帧”和“栈帧”。

“coroutine frame”保存协程激活帧的一部分，在协程挂起时持续存在，“stack frame”部分仅在协程执行时存在，并在协程挂起并将执行转移回调用者/恢复者时释放。

### “暂停”操作

协程的Suspend操作允许协程在函数中间暂停执行，并将执行转移回协程的调用者或恢复者。

协程体内的某些点被指定为挂起点。在 C++ Coroutines TS 中，这些挂起点是通过使用 co_await 或 co_yield 关键字来识别的。

当协程遇到这些挂起点之一时，它首先准备协程以通过以下方式恢复：

将一个值写入协程帧，指示协程被挂起的挂起点。这允许后续的 Resume 操作知道在哪里恢复协程的执行，或者后续的 Destroy 知道哪些值在范围内并且需要被销毁。

一旦协程准备好恢复，协程就被认为是“暂停的”。

然后协程有机会在执行被转移回调用者/恢复者之前执行一些额外的逻辑。 这个额外的逻辑被授予访问协程框架句柄的权限，该句柄可用于稍后恢复或销毁它。

这种在协程进入“挂起”状态后执行逻辑的能力允许协程被安排恢复而不需要同步，否则如果协程在进入“挂起”状态之前被安排恢复则需要同步，因为 暂停和恢复协程以竞争的可能性。 我将在以后的帖子中对此进行更详细的介绍。

然后协程可以选择立即恢复/继续协程的执行，或者可以选择将执行转移回调用者/恢复者。

如果执行转移到调用者/恢复者，协程激活帧的栈帧部分将被释放并从堆栈中弹出。

### “恢复”操作

Resume 操作可以在当前处于“挂起”状态的协程上执行。

当一个函数想要恢复协程时，它需要有效地“调用”到函数的特定调用的中间。 resumer 识别要恢复的特定调用的方式是在提供给相应 Suspend 操作的协程帧句柄上调用 void resume() 方法。

就像正常的函数调用一样，对 resume() 的调用将分配一个新的堆栈帧并将调用者的返回地址存储在堆栈帧中，然后再将执行转移到该函数。

但是，它不会将执行转移到函数的开头，而是将执行转移到函数中上次挂起的点。 它通过从协程帧加载恢复点并跳转到该点来实现。

当协程接下来暂停或运行完成时，对 resume() 的调用将返回并恢复调用函数的执行。

### “销毁”操作

Destroy 操作在不恢复协程执行的情况下销毁协程帧。

此操作只能在挂起的协程上执行。

Destroy 操作与 Resume 操作非常相似，因为它重新激活协程的激活帧，包括分配新的栈帧和存储 Destroy 操作调用者的返回地址。

但是，它不是在最后一个挂起点将执行转移到协程体，而是将执行转移到另一个代码路径，该路径调用在挂起点作用域内的所有局部变量的析构函数，然后释放协程帧内存。

与 Resume 操作类似，Destroy 操作通过在相应的 Suspend 操作期间提供的协程帧句柄上调用 void destroy() 方法来识别要销毁的特定激活帧。

### 协程的“调用”操作

协程的调用操作与普通函数的调用操作非常相似。实际上，从调用者的角度来看没有区别。

然而，当函数运行完成时，调用操作不会仅在函数运行完成时返回给调用者，而是在协程到达其第一个挂起点时恢复调用者的执行。

当对协程执行 Call 操作时，调用者分配一个新的栈帧，将参数写入栈帧，将返回地址写入栈帧并将执行转移到协程。 这与调用普通函数完全相同。

协程所做的第一件事是在堆上分配一个协程帧，并将参数从栈帧复制/移动到协程帧中，以便参数的生命周期超出第一个挂起点。

### 协程的“返回”操作

协程的 Return 操作与普通函数的返回操作略有不同。

当协程执行返回语句（根据 TS 为 co_return）操作时，它会将返回值存储在某处（具体存储位置可以由协程自定义），然后析构任何作用域内的局部变量（但不包括参数） .

然后协程有机会在将执行转移回调用者/恢复者之前执行一些额外的逻辑。

这个额外的逻辑可能会执行一些操作来发布返回值，或者它可能会恢复另一个正在等待结果的协程。 它是完全可定制的。

协程然后执行挂起操作（保持协程帧处于活动状态）或销毁操作（销毁协程帧）。

然后根据挂起/销毁操作语义将执行转移回调用者/恢复者，从堆栈中弹出激活帧的堆栈帧组件。

重要的是要注意，传递给 Return 操作的返回值与从 Call 操作返回的返回值不同，因为返回操作可能在调用者从初始 Call 操作恢复后很长时间内执行。

## 一个例子

为了帮助将这些概念形象化，我想通过一个简单的例子来说明协程被调用、挂起和稍后恢复时会发生什么。

假设我们有一个函数（或协程）f() 调用协程 x(int a)。

在调用之前，我们的情况看起来有点像这样：

```
STACK                     REGISTERS               HEAP

                          +------+
+---------------+ <------ | rsp  |
|  f()          |         +------+
+---------------+
| ...           |
|               |
```

然后当 x(42) 被调用时，它首先为 x() 创建一个堆栈帧，就像普通函数一样。

```
STACK                     REGISTERS               HEAP
+----------------+ <-+
|  x()           |   |
| a  = 42        |   |
| ret= f()+0x123 |   |    +------+
+----------------+   +--- | rsp  |
|  f()           |        +------+
+----------------+
| ...            |
|                |
```

然后，一旦协程 x() 在堆上为协程帧分配了内存并将参数值复制/移动到协程帧中，我们将得到如下图所示的结果。请注意，编译器通常会将协程帧的地址保存在栈指针的单独寄存器中（例如，MSVC 将其存储在 rbp 寄存器中）。

```
STACK                     REGISTERS               HEAP
+----------------+ <-+
|  x()           |   |
| a  = 42        |   |                   +-->  +-----------+
| ret= f()+0x123 |   |    +------+       |     |  x()      |
+----------------+   +--- | rsp  |       |     | a =  42   |
|  f()           |        +------+       |     +-----------+
+----------------+        | rbp  | ------+
| ...            |        +------+
|                |
```

如果协程 x() 然后调用另一个普通函数 g() 它将看起来像这样。

```
STACK                     REGISTERS               HEAP
+----------------+ <-+
|  g()           |   |
| ret= x()+0x45  |   |
+----------------+   |
|  x()           |   |
| coroframe      | --|-------------------+
| a  = 42        |   |                   +-->  +-----------+
| ret= f()+0x123 |   |    +------+             |  x()      |
+----------------+   +--- | rsp  |             | a =  42   |
|  f()           |        +------+             +-----------+
+----------------+        | rbp  |
| ...            |        +------+
|                |
```

当 g() 返回时，它将破坏其激活帧并恢复 x() 的激活框架。假设我们将 g() 的返回值保存在存储在协程帧中的局部变量 b 中。

```
STACK                     REGISTERS               HEAP
+----------------+ <-+
|  x()           |   |
| a  = 42        |   |                   +-->  +-----------+
| ret= f()+0x123 |   |    +------+       |     |  x()      |
+----------------+   +--- | rsp  |       |     | a =  42   |
|  f()           |        +------+       |     | b = 789   |
+----------------+        | rbp  | ------+     +-----------+
| ...            |        +------+
|                |
```

如果 x() 现在遇到一个挂起点并在不破坏其激活帧的情况下挂起执行，则执行返回到 f()。

这导致 x() 的栈帧部分被弹出栈，同时将协程帧留在堆上。当协程第一次挂起时，返回值返回给调用者。此返回值通常包含挂起的协程帧的句柄，可用于稍后恢复它。当 x() 挂起时，它还会将 x() 的恢复点的地址存储在协程帧中（将其称为 RP 以表示恢复点）。

```
STACK                     REGISTERS               HEAP
                                        +----> +-----------+
                          +------+      |      |  x()      |
+----------------+ <----- | rsp  |      |      | a =  42   |
|  f()           |        +------+      |      | b = 789   |
| handle     ----|---+    | rbp  |      |      | RP=x()+99 |
| ...            |   |    +------+      |      +-----------+
|                |   |                  |
|                |   +------------------+
```

这个句柄现在可以作为函数之间的正常值传递。在稍后的某个时间点，可能来自不同的调用栈，甚至在不同的线程上，某些东西（比如 h()）将决定恢复执行该协程。 例如，当异步 I/O 操作完成时。

恢复协程的函数调用 void resume(handle) 函数来恢复协程的执行。对于调用者来说，这看起来就像任何其他对带有单个参数的返回 void 的函数的正常调用。

这将创建一个新的栈帧，记录 resume() 调用者的返回地址，通过将其地址加载到寄存器中来激活协程帧，并在协程帧中存储的恢复点恢复执行 x()。

```
STACK                     REGISTERS               HEAP
+----------------+ <-+
|  x()           |   |                   +-->  +-----------+
| ret= h()+0x87  |   |    +------+       |     |  x()      |
+----------------+   +--- | rsp  |       |     | a =  42   |
|  h()           |        +------+       |     | b = 789   |
| handle         |        | rbp  | ------+     +-----------+
+----------------+        +------+
| ...            |
|                |
```

## 总结

我将协程描述为函数的泛化，除了“正常”函数提供的“调用”和“返回”操作之外，还具有三个附加操作——“暂停”、“恢复”和“销毁”。

我希望这为如何思考协程及其控制流提供了一些有用的心理框架。

在下一篇文章中，我将介绍 C++ Coroutines TS 语言扩展的机制，并解释编译器如何将您编写的代码翻译成协程。


> 本文翻译自：[Coroutine Theory](https://lewissbaker.github.io/2017/09/25/coroutine-theory)
